<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CG3D Basic Engine: igl::FastWindingNumber::UT_Array&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CG3D Basic Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>igl</b></li><li class="navelem"><b>FastWindingNumber</b></li><li class="navelem"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classigl_1_1_fast_winding_number_1_1_u_t___array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">igl::FastWindingNumber::UT_Array&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for igl::FastWindingNumber::UT_Array&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classigl_1_1_fast_winding_number_1_1_u_t___array.png" usemap="#igl::FastWindingNumber::UT_5FArray_3C_20T_20_3E_map" alt=""/>
  <map id="igl::FastWindingNumber::UT_5FArray_3C_20T_20_3E_map" name="igl::FastWindingNumber::UT_5FArray_3C_20T_20_3E_map">
<area href="classigl_1_1_fast_winding_number_1_1_u_t___small_array.html" alt="igl::FastWindingNumber::UT_SmallArray&lt; T, MAX_BYTES &gt;" shape="rect" coords="0,56,351,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">base_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acc0fceb96e6d3b0a756fdffea9992993"><td class="memItemLeft" align="right" valign="top"><a id="acc0fceb96e6d3b0a756fdffea9992993" name="acc0fceb96e6d3b0a756fdffea9992993"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:acc0fceb96e6d3b0a756fdffea9992993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19efa86ef702cae8d5ad3dc4478ef5b4"><td class="memItemLeft" align="right" valign="top"><a id="a19efa86ef702cae8d5ad3dc4478ef5b4" name="a19efa86ef702cae8d5ad3dc4478ef5b4"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>Comparator</b>) (const T *, const T *)</td></tr>
<tr class="separator:a19efa86ef702cae8d5ad3dc4478ef5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e87609a80ec269f8025cf40f4e7bbb"><td class="memItemLeft" align="right" valign="top"><a id="a44e87609a80ec269f8025cf40f4e7bbb" name="a44e87609a80ec269f8025cf40f4e7bbb"></a>
typedef <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">base_iterator</a>&lt; T, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a44e87609a80ec269f8025cf40f4e7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d11d269bd20cb0d4949d0c8f12d66ff"><td class="memItemLeft" align="right" valign="top"><a id="a5d11d269bd20cb0d4949d0c8f12d66ff" name="a5d11d269bd20cb0d4949d0c8f12d66ff"></a>
typedef <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">base_iterator</a>&lt; const T, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a5d11d269bd20cb0d4949d0c8f12d66ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cebaa3cf5cd9aa828d845924459fc5"><td class="memItemLeft" align="right" valign="top"><a id="a75cebaa3cf5cd9aa828d845924459fc5" name="a75cebaa3cf5cd9aa828d845924459fc5"></a>
typedef <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">base_iterator</a>&lt; T, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a75cebaa3cf5cd9aa828d845924459fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79523ebc10138d3b17edc091c2e5b588"><td class="memItemLeft" align="right" valign="top"><a id="a79523ebc10138d3b17edc091c2e5b588" name="a79523ebc10138d3b17edc091c2e5b588"></a>
typedef <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">base_iterator</a>&lt; const T, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a79523ebc10138d3b17edc091c2e5b588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e52dd0aeea0d07e7ca627b3741cf56"><td class="memItemLeft" align="right" valign="top"><a id="ae0e52dd0aeea0d07e7ca627b3741cf56" name="ae0e52dd0aeea0d07e7ca627b3741cf56"></a>
typedef <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>traverser</b></td></tr>
<tr class="separator:ae0e52dd0aeea0d07e7ca627b3741cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf8f280759fd78e07705b71d95f11121"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#adf8f280759fd78e07705b71d95f11121">UT_Array</a> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:adf8f280759fd78e07705b71d95f11121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e0f5fc58140f76dd97cab3d20e23d"><td class="memItemLeft" align="right" valign="top"><a id="ad75e0f5fc58140f76dd97cab3d20e23d" name="ad75e0f5fc58140f76dd97cab3d20e23d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UT_Array</b> (<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&amp;a) noexcept</td></tr>
<tr class="memdesc:ad75e0f5fc58140f76dd97cab3d20e23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Steals the working data from the original. <br /></td></tr>
<tr class="separator:ad75e0f5fc58140f76dd97cab3d20e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ba715d86bb6d5404cb9d8c26cb407"><td class="memItemLeft" align="right" valign="top"><a id="a5c7ba715d86bb6d5404cb9d8c26cb407" name="a5c7ba715d86bb6d5404cb9d8c26cb407"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UT_Array</b> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity</a>, exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size</a>)</td></tr>
<tr class="memdesc:a5c7ba715d86bb6d5404cb9d8c26cb407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based on given capacity and size. <br /></td></tr>
<tr class="separator:a5c7ba715d86bb6d5404cb9d8c26cb407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2390f758b6ab0cdf2e1c28f799058"><td class="memItemLeft" align="right" valign="top"><a id="a41d2390f758b6ab0cdf2e1c28f799058" name="a41d2390f758b6ab0cdf2e1c28f799058"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UT_Array</b> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity</a>=0)</td></tr>
<tr class="memdesc:a41d2390f758b6ab0cdf2e1c28f799058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based on given capacity with a size of 0. <br /></td></tr>
<tr class="separator:a41d2390f758b6ab0cdf2e1c28f799058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda6dfe0e5137c7af4becaf2f787969b"><td class="memItemLeft" align="right" valign="top"><a id="acda6dfe0e5137c7af4becaf2f787969b" name="acda6dfe0e5137c7af4becaf2f787969b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UT_Array</b> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:acda6dfe0e5137c7af4becaf2f787969b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with the contents of an initializer list. <br /></td></tr>
<tr class="separator:acda6dfe0e5137c7af4becaf2f787969b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1acf73c6e60c5b7f1ffd3d2634b925c"><td class="memItemLeft" align="right" valign="top"><a id="af1acf73c6e60c5b7f1ffd3d2634b925c" name="af1acf73c6e60c5b7f1ffd3d2634b925c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:af1acf73c6e60c5b7f1ffd3d2634b925c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ad48b73ba1dbc8033b8f5c96683a7"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a140ad48b73ba1dbc8033b8f5c96683a7">append</a> (void)</td></tr>
<tr class="separator:a140ad48b73ba1dbc8033b8f5c96683a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010b68b9f753179e6f054a3205866ac"><td class="memItemLeft" align="right" valign="top"><a id="ac010b68b9f753179e6f054a3205866ac" name="ac010b68b9f753179e6f054a3205866ac"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const T &amp;t)</td></tr>
<tr class="separator:ac010b68b9f753179e6f054a3205866ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7d40555670e3993ccb43d04024257"><td class="memItemLeft" align="right" valign="top"><a id="a0ee7d40555670e3993ccb43d04024257" name="a0ee7d40555670e3993ccb43d04024257"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (T &amp;&amp;t)</td></tr>
<tr class="separator:a0ee7d40555670e3993ccb43d04024257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9847b31e7d3a7ca89170228884745"><td class="memItemLeft" align="right" valign="top"><a id="a0bd9847b31e7d3a7ca89170228884745" name="a0bd9847b31e7d3a7ca89170228884745"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const T *pt, exint count)</td></tr>
<tr class="separator:a0bd9847b31e7d3a7ca89170228884745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84c26806788d2137bbf7e6390f643bf"><td class="memItemLeft" align="right" valign="top"><a id="ac84c26806788d2137bbf7e6390f643bf" name="ac84c26806788d2137bbf7e6390f643bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendMultiple</b> (const T &amp;t, exint count)</td></tr>
<tr class="separator:ac84c26806788d2137bbf7e6390f643bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074d041348a0858d51e09097ccc17c2"><td class="memItemLeft" align="right" valign="top"><a id="a9074d041348a0858d51e09097ccc17c2" name="a9074d041348a0858d51e09097ccc17c2"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>)</td></tr>
<tr class="separator:a9074d041348a0858d51e09097ccc17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeea0079f2066978b8d473b49f4cc0a7"><td class="memItemLeft" align="right" valign="top"><a id="afeea0079f2066978b8d473b49f4cc0a7" name="afeea0079f2066978b8d473b49f4cc0a7"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const T &amp;t, exint i)</td></tr>
<tr class="separator:afeea0079f2066978b8d473b49f4cc0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0642f7072460406271b53b3488ca50c"><td class="memItemLeft" align="right" valign="top"><a id="aa0642f7072460406271b53b3488ca50c" name="aa0642f7072460406271b53b3488ca50c"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (T &amp;&amp;t, exint i)</td></tr>
<tr class="separator:aa0642f7072460406271b53b3488ca50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b53174ad7d2486a42ee2232ea5a07"><td class="memTemplParams" colspan="2">template&lt;typename... S&gt; </td></tr>
<tr class="memitem:a3c4b53174ad7d2486a42ee2232ea5a07"><td class="memTemplItemLeft" align="right" valign="top">exint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a3c4b53174ad7d2486a42ee2232ea5a07">emplace_back</a> (S &amp;&amp;... s)</td></tr>
<tr class="separator:a3c4b53174ad7d2486a42ee2232ea5a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2695ad1a0b9198290835213bad2abeff"><td class="memItemLeft" align="right" valign="top"><a id="a2695ad1a0b9198290835213bad2abeff" name="a2695ad1a0b9198290835213bad2abeff"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>concat</b> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a2695ad1a0b9198290835213bad2abeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes another T array and concatenate it onto my end. <br /></td></tr>
<tr class="separator:a2695ad1a0b9198290835213bad2abeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98fccddfe22f12e28c70bdad680b43b"><td class="memItemLeft" align="right" valign="top"><a id="ad98fccddfe22f12e28c70bdad680b43b" name="ad98fccddfe22f12e28c70bdad680b43b"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>multipleInsert</b> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>, exint count)</td></tr>
<tr class="memdesc:ad98fccddfe22f12e28c70bdad680b43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element "count" times at the given index. Return the index. <br /></td></tr>
<tr class="separator:ad98fccddfe22f12e28c70bdad680b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b6a46428de2308d40950073c18bc5"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ad07b6a46428de2308d40950073c18bc5">insertAt</a> (const T &amp;t, exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>)</td></tr>
<tr class="separator:ad07b6a46428de2308d40950073c18bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed4961c1ea673be6f70038f356c1c91"><td class="memItemLeft" align="right" valign="top"><a id="a3ed4961c1ea673be6f70038f356c1c91" name="a3ed4961c1ea673be6f70038f356c1c91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidIndex</b> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>) const</td></tr>
<tr class="memdesc:a3ed4961c1ea673be6f70038f356c1c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if given index is valid. <br /></td></tr>
<tr class="separator:a3ed4961c1ea673be6f70038f356c1c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29690cf75558aff875f4c02237c8d464"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a29690cf75558aff875f4c02237c8d464">removeIndex</a> (exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>)</td></tr>
<tr class="separator:a29690cf75558aff875f4c02237c8d464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac951d26be104bae01bb58b4df8834952"><td class="memItemLeft" align="right" valign="top"><a id="ac951d26be104bae01bb58b4df8834952" name="ac951d26be104bae01bb58b4df8834952"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeLast</b> ()</td></tr>
<tr class="separator:ac951d26be104bae01bb58b4df8834952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36de43c7e9ad2d445035c9dcbf25c6d8"><td class="memItemLeft" align="right" valign="top"><a id="a36de43c7e9ad2d445035c9dcbf25c6d8" name="a36de43c7e9ad2d445035c9dcbf25c6d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeRange</b> (exint begin_i, exint end_i)</td></tr>
<tr class="memdesc:a36de43c7e9ad2d445035c9dcbf25c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the range [begin_i,end_i) of elements from the array. <br /></td></tr>
<tr class="separator:a36de43c7e9ad2d445035c9dcbf25c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefb8a486a04d0e5f08f6c58f68541b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#aeefb8a486a04d0e5f08f6c58f68541b5">extractRange</a> (exint begin_i, exint end_i, <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;dest)</td></tr>
<tr class="separator:aeefb8a486a04d0e5f08f6c58f68541b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c52782319006f1e504153f530e63039"><td class="memTemplParams" colspan="2">template&lt;typename IsEqual &gt; </td></tr>
<tr class="memitem:a8c52782319006f1e504153f530e63039"><td class="memTemplItemLeft" align="right" valign="top">exint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a8c52782319006f1e504153f530e63039">removeIf</a> (IsEqual is_equal)</td></tr>
<tr class="separator:a8c52782319006f1e504153f530e63039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c735e26b1335e8dd86b73df69736947"><td class="memTemplParams" colspan="2"><a id="a9c735e26b1335e8dd86b73df69736947" name="a9c735e26b1335e8dd86b73df69736947"></a>
template&lt;typename IsEqual &gt; </td></tr>
<tr class="memitem:a9c735e26b1335e8dd86b73df69736947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collapseIf</b> (IsEqual is_equal)</td></tr>
<tr class="memdesc:a9c735e26b1335e8dd86b73df69736947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all matching elements. Also sets the capacity of the array. <br /></td></tr>
<tr class="separator:a9c735e26b1335e8dd86b73df69736947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694703a9ef2fcf451d05eab8d3e5d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a4694703a9ef2fcf451d05eab8d3e5d64">move</a> (exint srcIdx, exint destIdx, exint howMany)</td></tr>
<tr class="separator:a4694703a9ef2fcf451d05eab8d3e5d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f5ecad22c57062c6fe539578f34dd"><td class="memItemLeft" align="right" valign="top"><a id="a8d1f5ecad22c57062c6fe539578f34dd" name="a8d1f5ecad22c57062c6fe539578f34dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cycle</b> (exint howMany)</td></tr>
<tr class="memdesc:a8d1f5ecad22c57062c6fe539578f34dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclically shifts the entire array by howMany. <br /></td></tr>
<tr class="separator:a8d1f5ecad22c57062c6fe539578f34dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af902775ca5cde5654c7091b7dd5b4de0"><td class="memItemLeft" align="right" valign="top"><a id="af902775ca5cde5654c7091b7dd5b4de0" name="af902775ca5cde5654c7091b7dd5b4de0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>constant</b> (const T &amp;v)</td></tr>
<tr class="memdesc:af902775ca5cde5654c7091b7dd5b4de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly set the array to a single value. <br /></td></tr>
<tr class="separator:af902775ca5cde5654c7091b7dd5b4de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd58c3d8280d2343309edbeac874ee"><td class="memItemLeft" align="right" valign="top"><a id="a5dfd58c3d8280d2343309edbeac874ee" name="a5dfd58c3d8280d2343309edbeac874ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zero</b> ()</td></tr>
<tr class="memdesc:a5dfd58c3d8280d2343309edbeac874ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros the array if a POD type, else trivial constructs if a class type. <br /></td></tr>
<tr class="separator:a5dfd58c3d8280d2343309edbeac874ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9958794c572494cb740e8a22de4a8d3e"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a> (const T &amp;t) const</td></tr>
<tr class="separator:a9958794c572494cb740e8a22de4a8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5137a8ba095d150bdbacaaa833742d"><td class="memItemLeft" align="right" valign="top"><a id="a9e5137a8ba095d150bdbacaaa833742d" name="a9e5137a8ba095d150bdbacaaa833742d"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>safeIndex</b> (const T &amp;t) const</td></tr>
<tr class="separator:a9e5137a8ba095d150bdbacaaa833742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae442a75d1123fab261704d6aa2eb09bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ae442a75d1123fab261704d6aa2eb09bf">setCapacity</a> (exint newcapacity)</td></tr>
<tr class="separator:ae442a75d1123fab261704d6aa2eb09bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c46f8dd1bbe414156c79e3ece8ab4"><td class="memItemLeft" align="right" valign="top"><a id="a2d3c46f8dd1bbe414156c79e3ece8ab4" name="a2d3c46f8dd1bbe414156c79e3ece8ab4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCapacityIfNeeded</b> (exint mincapacity)</td></tr>
<tr class="separator:a2d3c46f8dd1bbe414156c79e3ece8ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75b18b779a3e20eef93231e94bd475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#acb75b18b779a3e20eef93231e94bd475">bumpCapacity</a> (exint mincapacity)</td></tr>
<tr class="separator:acb75b18b779a3e20eef93231e94bd475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02efc2b417601c33a99655bc9ef343a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a02efc2b417601c33a99655bc9ef343a3">bumpSize</a> (exint newsize)</td></tr>
<tr class="separator:a02efc2b417601c33a99655bc9ef343a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3218d5d79170fef5f15e93ed0b2ebb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ae3218d5d79170fef5f15e93ed0b2ebb4">bumpEntries</a> (exint newsize)</td></tr>
<tr class="separator:ae3218d5d79170fef5f15e93ed0b2ebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2479417859af5f4c89b35e044f8bbb10"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity</a> () const</td></tr>
<tr class="separator:a2479417859af5f4c89b35e044f8bbb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625a85de3ac591c9bbce3fcaad595a7f"><td class="memItemLeft" align="right" valign="top">exint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size</a> () const</td></tr>
<tr class="separator:a625a85de3ac591c9bbce3fcaad595a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8b5fe5a95f37100cf5e32e46251f8"><td class="memItemLeft" align="right" valign="top"><a id="acfc8b5fe5a95f37100cf5e32e46251f8" name="acfc8b5fe5a95f37100cf5e32e46251f8"></a>
exint&#160;</td><td class="memItemRight" valign="bottom"><b>entries</b> () const</td></tr>
<tr class="memdesc:acfc8b5fe5a95f37100cf5e32e46251f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size()</a>. <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size()</a> is preferred. <br /></td></tr>
<tr class="separator:acfc8b5fe5a95f37100cf5e32e46251f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e773ca0915a12741f0b0e12b8f91e18"><td class="memItemLeft" align="right" valign="top"><a id="a5e773ca0915a12741f0b0e12b8f91e18" name="a5e773ca0915a12741f0b0e12b8f91e18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> () const</td></tr>
<tr class="memdesc:a5e773ca0915a12741f0b0e12b8f91e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff there are no occupied elements in the array. <br /></td></tr>
<tr class="separator:a5e773ca0915a12741f0b0e12b8f91e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd969d3ad868d31090bf6eb7a4bce14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9fd969d3ad868d31090bf6eb7a4bce14">setSize</a> (exint newsize)</td></tr>
<tr class="separator:a9fd969d3ad868d31090bf6eb7a4bce14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228c8c3e710413d67c11f2b206d106b"><td class="memItemLeft" align="right" valign="top"><a id="ae228c8c3e710413d67c11f2b206d106b" name="ae228c8c3e710413d67c11f2b206d106b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>entries</b> (exint newsize)</td></tr>
<tr class="memdesc:ae228c8c3e710413d67c11f2b206d106b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9fd969d3ad868d31090bf6eb7a4bce14">setSize()</a>. <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9fd969d3ad868d31090bf6eb7a4bce14">setSize()</a> is preferred. <br /></td></tr>
<tr class="separator:ae228c8c3e710413d67c11f2b206d106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7573f544d51dc701670a7cf8211222a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a7573f544d51dc701670a7cf8211222a5">setSizeNoInit</a> (exint newsize)</td></tr>
<tr class="separator:a7573f544d51dc701670a7cf8211222a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86494e23ca4943fdf687807c119f6ab"><td class="memItemLeft" align="right" valign="top"><a id="ab86494e23ca4943fdf687807c119f6ab" name="ab86494e23ca4943fdf687807c119f6ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>truncate</b> (exint maxsize)</td></tr>
<tr class="memdesc:ab86494e23ca4943fdf687807c119f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases, but never expands, to the given maxsize. <br /></td></tr>
<tr class="separator:ab86494e23ca4943fdf687807c119f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755013053c091a0bd13e0f370838f434"><td class="memItemLeft" align="right" valign="top"><a id="a755013053c091a0bd13e0f370838f434" name="a755013053c091a0bd13e0f370838f434"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a755013053c091a0bd13e0f370838f434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets list to an empty list. <br /></td></tr>
<tr class="separator:a755013053c091a0bd13e0f370838f434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebaaaf5fa3b90dc980983447486bae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a60ebaaaf5fa3b90dc980983447486bae">operator=</a> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a60ebaaaf5fa3b90dc980983447486bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8505b2f5f49e28c072c70d31813c4ba"><td class="memItemLeft" align="right" valign="top"><a id="af8505b2f5f49e28c072c70d31813c4ba" name="af8505b2f5f49e28c072c70d31813c4ba"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:af8505b2f5f49e28c072c70d31813c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents with those from the initializer_list ilist. <br /></td></tr>
<tr class="separator:af8505b2f5f49e28c072c70d31813c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad173599c56da1be877e35488f9caefdb"><td class="memItemLeft" align="right" valign="top"><a id="ad173599c56da1be877e35488f9caefdb" name="ad173599c56da1be877e35488f9caefdb"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&amp;a)</td></tr>
<tr class="memdesc:ad173599c56da1be877e35488f9caefdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the contents of array a to this array. <br /></td></tr>
<tr class="separator:ad173599c56da1be877e35488f9caefdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922ba8f243621b5e78cad499bc041c4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a922ba8f243621b5e78cad499bc041c4e">operator==</a> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;a) const</td></tr>
<tr class="separator:a922ba8f243621b5e78cad499bc041c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c87d7854b9b3362bb2b32cb81a7a00"><td class="memItemLeft" align="right" valign="top"><a id="ae0c87d7854b9b3362bb2b32cb81a7a00" name="ae0c87d7854b9b3362bb2b32cb81a7a00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;a) const</td></tr>
<tr class="separator:ae0c87d7854b9b3362bb2b32cb81a7a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8951054a7dd3dd2a9471a2b1b63b27fd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a8951054a7dd3dd2a9471a2b1b63b27fd">operator()</a> (exint i)</td></tr>
<tr class="separator:a8951054a7dd3dd2a9471a2b1b63b27fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3349de76ae0b1c267cb9a980e2a2ba3b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a3349de76ae0b1c267cb9a980e2a2ba3b">operator()</a> (exint i) const</td></tr>
<tr class="separator:a3349de76ae0b1c267cb9a980e2a2ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d5332bd0f094ad9ac78d0f6b936e5d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a29d5332bd0f094ad9ac78d0f6b936e5d">operator[]</a> (exint i)</td></tr>
<tr class="separator:a29d5332bd0f094ad9ac78d0f6b936e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc788c700438a0f838e5420420f4fb8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#abfc788c700438a0f838e5420420f4fb8">operator[]</a> (exint i) const</td></tr>
<tr class="separator:abfc788c700438a0f838e5420420f4fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85611bc8d8cc844dcc7f466e4cd539f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ac85611bc8d8cc844dcc7f466e4cd539f">forcedRef</a> (exint i)</td></tr>
<tr class="separator:ac85611bc8d8cc844dcc7f466e4cd539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482514e3e5cd51ff06549884fbaf415e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a482514e3e5cd51ff06549884fbaf415e">forcedGet</a> (exint i) const</td></tr>
<tr class="separator:a482514e3e5cd51ff06549884fbaf415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dd678a83ecc34a3fd4650bc1095e21"><td class="memItemLeft" align="right" valign="top"><a id="ab8dd678a83ecc34a3fd4650bc1095e21" name="ab8dd678a83ecc34a3fd4650bc1095e21"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>last</b> ()</td></tr>
<tr class="separator:ab8dd678a83ecc34a3fd4650bc1095e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6acb142aacf3e98475c1bcb11e5bf23"><td class="memItemLeft" align="right" valign="top"><a id="af6acb142aacf3e98475c1bcb11e5bf23" name="af6acb142aacf3e98475c1bcb11e5bf23"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>last</b> () const</td></tr>
<tr class="separator:af6acb142aacf3e98475c1bcb11e5bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaade04703fc7998d9e14f662178fea"><td class="memItemLeft" align="right" valign="top"><a id="afcaade04703fc7998d9e14f662178fea" name="afcaade04703fc7998d9e14f662178fea"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>getArray</b> () const</td></tr>
<tr class="separator:afcaade04703fc7998d9e14f662178fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aa9a31422b9ef05a9c88f91841c91f"><td class="memItemLeft" align="right" valign="top"><a id="ad8aa9a31422b9ef05a9c88f91841c91f" name="ad8aa9a31422b9ef05a9c88f91841c91f"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>getRawArray</b> () const</td></tr>
<tr class="separator:ad8aa9a31422b9ef05a9c88f91841c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad348fdc8127784b1f890ce75f0334d10"><td class="memItemLeft" align="right" valign="top"><a id="ad348fdc8127784b1f890ce75f0334d10" name="ad348fdc8127784b1f890ce75f0334d10"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> ()</td></tr>
<tr class="separator:ad348fdc8127784b1f890ce75f0334d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635d9aa1fe7715d13d6c7a3352f35883"><td class="memItemLeft" align="right" valign="top"><a id="a635d9aa1fe7715d13d6c7a3352f35883" name="a635d9aa1fe7715d13d6c7a3352f35883"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> () const</td></tr>
<tr class="separator:a635d9aa1fe7715d13d6c7a3352f35883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd2bf97b6e55a35a59b4d0f8ec7a1df"><td class="memItemLeft" align="right" valign="top"><a id="adfd2bf97b6e55a35a59b4d0f8ec7a1df" name="adfd2bf97b6e55a35a59b4d0f8ec7a1df"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="separator:adfd2bf97b6e55a35a59b4d0f8ec7a1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134280217c3430803621ed502bdd0ba"><td class="memItemLeft" align="right" valign="top"><a id="ae134280217c3430803621ed502bdd0ba" name="ae134280217c3430803621ed502bdd0ba"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:ae134280217c3430803621ed502bdd0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c3f9cf557153194b32b80d23bcc043"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#af7c3f9cf557153194b32b80d23bcc043">aliasArray</a> (T *newdata)</td></tr>
<tr class="separator:af7c3f9cf557153194b32b80d23bcc043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2056589651b7e0d340552fab32a268aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2056589651b7e0d340552fab32a268aa">begin</a> ()</td></tr>
<tr class="separator:a2056589651b7e0d340552fab32a268aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06da7d0367e9c745cf58692a80e6c9d"><td class="memItemLeft" align="right" valign="top"><a id="ac06da7d0367e9c745cf58692a80e6c9d" name="ac06da7d0367e9c745cf58692a80e6c9d"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="memdesc:ac06da7d0367e9c745cf58692a80e6c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator. <br /></td></tr>
<tr class="separator:ac06da7d0367e9c745cf58692a80e6c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c546c81d9f5b098dd419e53c1388314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a6c546c81d9f5b098dd419e53c1388314">begin</a> () const</td></tr>
<tr class="separator:a6c546c81d9f5b098dd419e53c1388314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c829d467a4af51483ab6464d5dd1b"><td class="memItemLeft" align="right" valign="top"><a id="a436c829d467a4af51483ab6464d5dd1b" name="a436c829d467a4af51483ab6464d5dd1b"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memdesc:a436c829d467a4af51483ab6464d5dd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End const iterator. Consider using it.atEnd() instead. <br /></td></tr>
<tr class="separator:a436c829d467a4af51483ab6464d5dd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a9f4c44e40defff47d921b6d62c6a"><td class="memItemLeft" align="right" valign="top"><a id="a7b7a9f4c44e40defff47d921b6d62c6a" name="a7b7a9f4c44e40defff47d921b6d62c6a"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="memdesc:a7b7a9f4c44e40defff47d921b6d62c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterating over the array in reverse. <br /></td></tr>
<tr class="separator:a7b7a9f4c44e40defff47d921b6d62c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9916be348e380351e2a925f3a4df34"><td class="memItemLeft" align="right" valign="top"><a id="a3d9916be348e380351e2a925f3a4df34" name="a3d9916be348e380351e2a925f3a4df34"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="memdesc:a3d9916be348e380351e2a925f3a4df34"><td class="mdescLeft">&#160;</td><td class="mdescRight">End reverse iterator. <br /></td></tr>
<tr class="separator:a3d9916be348e380351e2a925f3a4df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc952164afa717a651fa469b9ff31a9a"><td class="memItemLeft" align="right" valign="top"><a id="adc952164afa717a651fa469b9ff31a9a" name="adc952164afa717a651fa469b9ff31a9a"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="memdesc:adc952164afa717a651fa469b9ff31a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterating over the array in reverse. <br /></td></tr>
<tr class="separator:adc952164afa717a651fa469b9ff31a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0098151cabadb8e0fb0ba40327d736f"><td class="memItemLeft" align="right" valign="top"><a id="ab0098151cabadb8e0fb0ba40327d736f" name="ab0098151cabadb8e0fb0ba40327d736f"></a>
<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="memdesc:ab0098151cabadb8e0fb0ba40327d736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End reverse iterator. Consider using it.atEnd() instead. <br /></td></tr>
<tr class="separator:ab0098151cabadb8e0fb0ba40327d736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e9e8593d6f28cefa4dc0c4d5b8f843"><td class="memItemLeft" align="right" valign="top"><a id="ad0e9e8593d6f28cefa4dc0c4d5b8f843" name="ad0e9e8593d6f28cefa4dc0c4d5b8f843"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeItem</b> (const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">reverse_iterator</a> &amp;it)</td></tr>
<tr class="memdesc:ad0e9e8593d6f28cefa4dc0c4d5b8f843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove item specified by the reverse_iterator. <br /></td></tr>
<tr class="separator:ad0e9e8593d6f28cefa4dc0c4d5b8f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359db526d4c3f8243a695da3913d54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a6359db526d4c3f8243a695da3913d54f">unsafeShareData</a> (<a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:a6359db526d4c3f8243a695da3913d54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23496ee9b71a7db8b67a469d2ad55b1"><td class="memItemLeft" align="right" valign="top"><a id="aa23496ee9b71a7db8b67a469d2ad55b1" name="aa23496ee9b71a7db8b67a469d2ad55b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unsafeShareData</b> (T *src, exint srcsize)</td></tr>
<tr class="separator:aa23496ee9b71a7db8b67a469d2ad55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65481d5882cc9e65d8dd64877f6c383"><td class="memItemLeft" align="right" valign="top"><a id="ae65481d5882cc9e65d8dd64877f6c383" name="ae65481d5882cc9e65d8dd64877f6c383"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unsafeShareData</b> (T *src, exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size</a>, exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity</a>)</td></tr>
<tr class="separator:ae65481d5882cc9e65d8dd64877f6c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeb2b85f13a08ca015869e7697feec4"><td class="memItemLeft" align="right" valign="top"><a id="a8eeb2b85f13a08ca015869e7697feec4" name="a8eeb2b85f13a08ca015869e7697feec4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unsafeClearData</b> ()</td></tr>
<tr class="separator:a8eeb2b85f13a08ca015869e7697feec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724e8c9e2217d7114933f1cbddc5a9c4"><td class="memItemLeft" align="right" valign="top"><a id="a724e8c9e2217d7114933f1cbddc5a9c4" name="a724e8c9e2217d7114933f1cbddc5a9c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHeapBuffer</b> () const</td></tr>
<tr class="memdesc:a724e8c9e2217d7114933f1cbddc5a9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the data used by the array was allocated on the heap. <br /></td></tr>
<tr class="separator:a724e8c9e2217d7114933f1cbddc5a9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb3e0ad77b9c6d1d679d205bff79f6d"><td class="memItemLeft" align="right" valign="top"><a id="a7fb3e0ad77b9c6d1d679d205bff79f6d" name="a7fb3e0ad77b9c6d1d679d205bff79f6d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isHeapBuffer</b> (T *data) const</td></tr>
<tr class="separator:a7fb3e0ad77b9c6d1d679d205bff79f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa381b185ffc8552f7e3c1196760095d6"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:aa381b185ffc8552f7e3c1196760095d6"><td class="memTemplItemLeft" align="right" valign="top">exint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#aa381b185ffc8552f7e3c1196760095d6">appendImpl</a> (S &amp;&amp;s)</td></tr>
<tr class="separator:aa381b185ffc8552f7e3c1196760095d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e9d9ad062b8c91722add065fe9534"><td class="memTemplParams" colspan="2"><a id="a398e9d9ad062b8c91722add065fe9534" name="a398e9d9ad062b8c91722add065fe9534"></a>
template&lt;typename S &gt; </td></tr>
<tr class="memitem:a398e9d9ad062b8c91722add065fe9534"><td class="memTemplItemLeft" align="right" valign="top">exint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insertImpl</b> (S &amp;&amp;s, exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index</a>)</td></tr>
<tr class="memdesc:a398e9d9ad062b8c91722add065fe9534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#aa381b185ffc8552f7e3c1196760095d6">appendImpl()</a> but for insertion. <br /></td></tr>
<tr class="separator:a398e9d9ad062b8c91722add065fe9534"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a039d5119db6959a435b974588515ebb2"><td class="memItemLeft" align="right" valign="top"><a id="a039d5119db6959a435b974588515ebb2" name="a039d5119db6959a435b974588515ebb2"></a>
static constexpr SYS_FORCE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPOD</b> ()</td></tr>
<tr class="separator:a039d5119db6959a435b974588515ebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6daf430fe0a15eba39bdcbf9c59df63"><td class="memTemplParams" colspan="2"><a id="ae6daf430fe0a15eba39bdcbf9c59df63" name="ae6daf430fe0a15eba39bdcbf9c59df63"></a>
template&lt;typename... S&gt; </td></tr>
<tr class="memitem:ae6daf430fe0a15eba39bdcbf9c59df63"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>construct</b> (T &amp;dst, S &amp;&amp;... s)</td></tr>
<tr class="separator:ae6daf430fe0a15eba39bdcbf9c59df63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3e137246210510bd80890c9d615d8"><td class="memItemLeft" align="right" valign="top"><a id="a74a3e137246210510bd80890c9d615d8" name="a74a3e137246210510bd80890c9d615d8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>copyConstruct</b> (T &amp;dst, const T &amp;src)</td></tr>
<tr class="separator:a74a3e137246210510bd80890c9d615d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55e3a7469a4916c4a05a503498fe7eb"><td class="memItemLeft" align="right" valign="top"><a id="aa55e3a7469a4916c4a05a503498fe7eb" name="aa55e3a7469a4916c4a05a503498fe7eb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>copyConstructRange</b> (T *dst, const T *src, exint n)</td></tr>
<tr class="separator:aa55e3a7469a4916c4a05a503498fe7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abd104c37be838f24beb067378188da"><td class="memItemLeft" align="right" valign="top"><a id="a3abd104c37be838f24beb067378188da" name="a3abd104c37be838f24beb067378188da"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>trivialConstruct</b> (T &amp;dst)</td></tr>
<tr class="memdesc:a3abd104c37be838f24beb067378188da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element Constructor. <br /></td></tr>
<tr class="separator:a3abd104c37be838f24beb067378188da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7aba7afa397baecfb38fed11e8cc3c"><td class="memItemLeft" align="right" valign="top"><a id="ace7aba7afa397baecfb38fed11e8cc3c" name="ace7aba7afa397baecfb38fed11e8cc3c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>trivialConstructRange</b> (T *dst, exint n)</td></tr>
<tr class="separator:ace7aba7afa397baecfb38fed11e8cc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd68eba1f6f35361e7fda3502d785bf"><td class="memItemLeft" align="right" valign="top"><a id="a2bd68eba1f6f35361e7fda3502d785bf" name="a2bd68eba1f6f35361e7fda3502d785bf"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>trivialDestruct</b> (T &amp;dst)</td></tr>
<tr class="memdesc:a2bd68eba1f6f35361e7fda3502d785bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element Destructor. <br /></td></tr>
<tr class="separator:a2bd68eba1f6f35361e7fda3502d785bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf87b499ab50b5b96debd0dc277f3e22"><td class="memItemLeft" align="right" valign="top"><a id="abf87b499ab50b5b96debd0dc277f3e22" name="abf87b499ab50b5b96debd0dc277f3e22"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>trivialDestructRange</b> (T *dst, exint n)</td></tr>
<tr class="separator:abf87b499ab50b5b96debd0dc277f3e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adf8f280759fd78e07705b71d95f11121" name="adf8f280759fd78e07705b71d95f11121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8f280759fd78e07705b71d95f11121">&#9670;&nbsp;</a></span>UT_Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::UT_Array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copy constructor. It duplicates the data. It's marked explicit so that it's not accidentally passed by value. You can always pass by reference and then copy it, if needed. If you have a line like: UT_Array&lt;int&gt; a = otherarray; and it really does need to copy instead of referencing, you can rewrite it as: UT_Array&lt;int&gt; a(otherarray); </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af7c3f9cf557153194b32b80d23bcc043" name="af7c3f9cf557153194b32b80d23bcc043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c3f9cf557153194b32b80d23bcc043">&#9670;&nbsp;</a></span>aliasArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::aliasArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method allows you to swap in a new raw T array, which must be the same size as myCapacity. Use caution with this method. </p>

</div>
</div>
<a id="a140ad48b73ba1dbc8033b8f5c96683a7" name="a140ad48b73ba1dbc8033b8f5c96683a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140ad48b73ba1dbc8033b8f5c96683a7">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Append an element to the current elements and return its index in the array, or insert the element at a specified position; if necessary, insert() grows the array to accommodate the element. The insert methods use the assignment operator '=' to place the element into the right spot; be aware that '=' works differently on objects and pointers. The test for duplicates uses the logical equal operator '=='; as with '=', the behaviour of the equality operator on pointers versus objects is not the same. Use the subscript operators instead of insert() if you are appending to the array, or if you don't mind overwriting the element already inserted at the given index. </p>

</div>
</div>
<a id="aa381b185ffc8552f7e3c1196760095d6" name="aa381b185ffc8552f7e3c1196760095d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa381b185ffc8552f7e3c1196760095d6">&#9670;&nbsp;</a></span>appendImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::appendImpl </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Implements both append(const T &amp;) and append(T &amp;&amp;) via perfect forwarding. Unlike the variadic <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a3c4b53174ad7d2486a42ee2232ea5a07">emplace_back()</a>, its argument may be a reference to another element in the array. </p>

</div>
</div>
<a id="a2056589651b7e0d340552fab32a268aa" name="a2056589651b7e0d340552fab32a268aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2056589651b7e0d340552fab32a268aa">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">iterator</a> <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Begin iterating over the array. The contents of the array may be modified during the traversal. </p>

</div>
</div>
<a id="a6c546c81d9f5b098dd419e53c1388314" name="a6c546c81d9f5b098dd419e53c1388314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c546c81d9f5b098dd419e53c1388314">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array_1_1base__iterator.html">const_iterator</a> <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Begin iterating over the array. The array may not be modified during the traversal. </p>

</div>
</div>
<a id="acb75b18b779a3e20eef93231e94bd475" name="acb75b18b779a3e20eef93231e94bd475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb75b18b779a3e20eef93231e94bd475">&#9670;&nbsp;</a></span>bumpCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::bumpCapacity </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>mincapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If the capacity is smaller than mincapacity, expand the array to at least mincapacity and to at least a constant factor of the array's previous capacity, to avoid having a linear number of reallocations in a linear number of calls to bumpCapacity. </p>

</div>
</div>
<a id="ae3218d5d79170fef5f15e93ed0b2ebb4" name="ae3218d5d79170fef5f15e93ed0b2ebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3218d5d79170fef5f15e93ed0b2ebb4">&#9670;&nbsp;</a></span>bumpEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::bumpEntries </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >NOTE: <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ae3218d5d79170fef5f15e93ed0b2ebb4">bumpEntries()</a> will be deprecated in favour of <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a02efc2b417601c33a99655bc9ef343a3">bumpSize()</a> in a future version. </p>

</div>
</div>
<a id="a02efc2b417601c33a99655bc9ef343a3" name="a02efc2b417601c33a99655bc9ef343a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02efc2b417601c33a99655bc9ef343a3">&#9670;&nbsp;</a></span>bumpSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::bumpSize </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >First bumpCapacity to ensure that there's space for newsize, expanding either not at all or by at least a constant factor of the array's previous capacity, then set the size to newsize. </p>

</div>
</div>
<a id="a2479417859af5f4c89b35e044f8bbb10" name="a2479417859af5f4c89b35e044f8bbb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2479417859af5f4c89b35e044f8bbb10">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Query the capacity, i.e. the allocated length of the array. NOTE: <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity()</a> &gt;= <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size()</a>. </p>

</div>
</div>
<a id="a3c4b53174ad7d2486a42ee2232ea5a07" name="a3c4b53174ad7d2486a42ee2232ea5a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b53174ad7d2486a42ee2232ea5a07">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;...&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds a new element to the array (resizing if necessary) and forwards the given arguments to T's constructor. NOTE: Unlike <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a140ad48b73ba1dbc8033b8f5c96683a7">append()</a>, the arguments cannot reference any existing elements in the array. Checking for and handling such cases would remove most of the performance gain versus append(T(...)). Debug builds will assert that the arguments are valid. </p>

</div>
</div>
<a id="aeefb8a486a04d0e5f08f6c58f68541b5" name="aeefb8a486a04d0e5f08f6c58f68541b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefb8a486a04d0e5f08f6c58f68541b5">&#9670;&nbsp;</a></span>extractRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::extractRange </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>begin_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>end_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove the range [begin_i, end_i) of elements from this array and place them in the dest array, shrinking/growing the dest array as necessary. </p>

</div>
</div>
<a id="a482514e3e5cd51ff06549884fbaf415e" name="a482514e3e5cd51ff06549884fbaf415e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482514e3e5cd51ff06549884fbaf415e">&#9670;&nbsp;</a></span>forcedGet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::forcedGet </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >forcedGet(exint) does NOT grow the array, and will return default objects for out of bound array indices. </p>

</div>
</div>
<a id="ac85611bc8d8cc844dcc7f466e4cd539f" name="ac85611bc8d8cc844dcc7f466e4cd539f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85611bc8d8cc844dcc7f466e4cd539f">&#9670;&nbsp;</a></span>forcedRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::forcedRef </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#ac85611bc8d8cc844dcc7f466e4cd539f">forcedRef(exint)</a> will grow the array if necessary, initializing any new elements to zero for POD types and default constructing for class types. </p>

</div>
</div>
<a id="a9958794c572494cb740e8a22de4a8d3e" name="a9958794c572494cb740e8a22de4a8d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9958794c572494cb740e8a22de4a8d3e">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The fastest search possible, which does pointer arithmetic to find the index of the element. WARNING: <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a9958794c572494cb740e8a22de4a8d3e">index()</a> does no out-of-bounds checking. </p>

</div>
</div>
<a id="ad07b6a46428de2308d40950073c18bc5" name="ad07b6a46428de2308d40950073c18bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07b6a46428de2308d40950073c18bc5">&#9670;&nbsp;</a></span>insertAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::insertAt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >An alias for unique element insertion at a certain index. Also used by the other insertion methods. </p>

</div>
</div>
<a id="a4694703a9ef2fcf451d05eab8d3e5d64" name="a4694703a9ef2fcf451d05eab8d3e5d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694703a9ef2fcf451d05eab8d3e5d64">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::move </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>srcIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>destIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>howMany</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Move howMany objects starting at index srcIndex to destIndex; This method will remove the elements at [srcIdx, srcIdx+howMany) and then insert them at destIdx. This method can be used in place of the old shift() operation. </p>

</div>
</div>
<a id="a8951054a7dd3dd2a9471a2b1b63b27fd" name="a8951054a7dd3dd2a9471a2b1b63b27fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8951054a7dd3dd2a9471a2b1b63b27fd">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Subscript operator NOTE: This does NOT do any bounds checking unless paranoid asserts are enabled. </p>

</div>
</div>
<a id="a3349de76ae0b1c267cb9a980e2a2ba3b" name="a3349de76ae0b1c267cb9a980e2a2ba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3349de76ae0b1c267cb9a980e2a2ba3b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Const subscript operator NOTE: This does NOT do any bounds checking unless paranoid asserts are enabled. </p>

</div>
</div>
<a id="a60ebaaaf5fa3b90dc980983447486bae" name="a60ebaaaf5fa3b90dc980983447486bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ebaaaf5fa3b90dc980983447486bae">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign array a to this array by copying each of a's elements with memcpy for POD types, and with copy construction for class types. </p>

</div>
</div>
<a id="a922ba8f243621b5e78cad499bc041c4e" name="a922ba8f243621b5e78cad499bc041c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922ba8f243621b5e78cad499bc041c4e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compare two array and return true if they are equal and false otherwise. Two elements are checked against each other using operator '==' or compare() respectively. NOTE: The capacities of the arrays are not checked when determining whether they are equal. </p>

</div>
</div>
<a id="a29d5332bd0f094ad9ac78d0f6b936e5d" name="a29d5332bd0f094ad9ac78d0f6b936e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d5332bd0f094ad9ac78d0f6b936e5d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Subscript operator NOTE: This does NOT do any bounds checking unless paranoid asserts are enabled. </p>

</div>
</div>
<a id="abfc788c700438a0f838e5420420f4fb8" name="abfc788c700438a0f838e5420420f4fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc788c700438a0f838e5420420f4fb8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Const subscript operator NOTE: This does NOT do any bounds checking unless paranoid asserts are enabled. </p>

</div>
</div>
<a id="a8c52782319006f1e504153f530e63039" name="a8c52782319006f1e504153f530e63039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c52782319006f1e504153f530e63039">&#9670;&nbsp;</a></span>removeIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename IsEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::removeIf </td>
          <td>(</td>
          <td class="paramtype">IsEqual&#160;</td>
          <td class="paramname"><em>is_equal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Removes all matching elements from the list, shuffling down and changing the size appropriately. Returns the number of elements left. </p>

</div>
</div>
<a id="a29690cf75558aff875f4c02237c8d464" name="a29690cf75558aff875f4c02237c8d464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29690cf75558aff875f4c02237c8d464">&#9670;&nbsp;</a></span>removeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::removeIndex </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove one element from the array given its position in the list, and fill the gap by shifting the elements down by one position. Return the index of the element removed or -1 if the index was out of bounds. </p>

</div>
</div>
<a id="ae442a75d1123fab261704d6aa2eb09bf" name="ae442a75d1123fab261704d6aa2eb09bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae442a75d1123fab261704d6aa2eb09bf">&#9670;&nbsp;</a></span>setCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::setCapacity </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>newcapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the capacity of the array, i.e. grow it or shrink it. The function copies the data after reallocating space for the array. </p>

</div>
</div>
<a id="a9fd969d3ad868d31090bf6eb7a4bce14" name="a9fd969d3ad868d31090bf6eb7a4bce14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd969d3ad868d31090bf6eb7a4bce14">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the size, the number of occupied elements in the array. NOTE: This will not do bumpCapacity, so if you call this n times to increase the size, it may take n^2 time. </p>

</div>
</div>
<a id="a7573f544d51dc701670a7cf8211222a5" name="a7573f544d51dc701670a7cf8211222a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7573f544d51dc701670a7cf8211222a5">&#9670;&nbsp;</a></span>setSizeNoInit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::setSizeNoInit </td>
          <td>(</td>
          <td class="paramtype">exint&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set the size, but unlike setSize(newsize), this function will not initialize new POD elements to zero. Non-POD data types will still have their constructors called. This function is faster than setSize(ne) if you intend to fill in data for all elements. </p>

</div>
</div>
<a id="a625a85de3ac591c9bbce3fcaad595a7f" name="a625a85de3ac591c9bbce3fcaad595a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625a85de3ac591c9bbce3fcaad595a7f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exint <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Query the size, i.e. the number of occupied elements in the array. NOTE: <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a2479417859af5f4c89b35e044f8bbb10">capacity()</a> &gt;= <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html#a625a85de3ac591c9bbce3fcaad595a7f">size()</a>. </p>

</div>
</div>
<a id="a6359db526d4c3f8243a695da3913d54f" name="a6359db526d4c3f8243a695da3913d54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359db526d4c3f8243a695da3913d54f">&#9670;&nbsp;</a></span>unsafeShareData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">igl::FastWindingNumber::UT_Array</a>&lt; T &gt;::unsafeShareData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classigl_1_1_fast_winding_number_1_1_u_t___array.html">UT_Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Very dangerous methods to share arrays. The array is not aware of the sharing, so ensure you clear out the array prior a destructor or setCapacity operation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>igl/<a class="el" href="_fast_winding_number_for_soups_8h_source.html">FastWindingNumberForSoups.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
