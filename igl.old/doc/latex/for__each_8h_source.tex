\hypertarget{for__each_8h_source}{}\doxysection{for\+\_\+each.\+h}
\label{for__each_8h_source}\index{igl/for\_each.h@{igl/for\_each.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef IGL\_FOR\_EACH\_H}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define IGL\_FOR\_EACH\_H}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include "{}igl\_inline.h"{}}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <Eigen/Core>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <Eigen/Sparse>}}
\DoxyCodeLine{6 \textcolor{keyword}{namespace }igl}
\DoxyCodeLine{7 \{}
\DoxyCodeLine{8   \textcolor{comment}{// FOR\_EACH  Call a given function for each non-\/zero (i.e., explicit value}}
\DoxyCodeLine{9   \textcolor{comment}{// might actually be ==0) in a Sparse Matrix A \_in order (of storage)\_. This is}}
\DoxyCodeLine{10   \textcolor{comment}{// useless unless func has \_side-\/effects\_.}}
\DoxyCodeLine{11   \textcolor{comment}{//}}
\DoxyCodeLine{12   \textcolor{comment}{// Inputs:}}
\DoxyCodeLine{13   \textcolor{comment}{//   A  m by n SparseMatrix}}
\DoxyCodeLine{14   \textcolor{comment}{//   func  function handle with prototype "{}compatible with"{} `void (Index i,}}
\DoxyCodeLine{15   \textcolor{comment}{//     Index j, Scalar \& v)`. Return values will be ignored.}}
\DoxyCodeLine{16   \textcolor{comment}{//}}
\DoxyCodeLine{17   \textcolor{comment}{// See also: std::for\_each}}
\DoxyCodeLine{18   \textcolor{keyword}{template} <\textcolor{keyword}{typename} AType, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{19   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} for\_each(}
\DoxyCodeLine{20     \textcolor{keyword}{const} Eigen::SparseMatrix<AType> \& A,}
\DoxyCodeLine{21     \textcolor{keyword}{const} Func \& func);}
\DoxyCodeLine{22   \textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{23   \textcolor{keyword}{inline} \textcolor{keywordtype}{void} for\_each(}
\DoxyCodeLine{24     \textcolor{keyword}{const} Eigen::DenseBase<DerivedA> \& A,}
\DoxyCodeLine{25     \textcolor{keyword}{const} Func \& func);}
\DoxyCodeLine{26 \}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{comment}{// Implementation}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{template} <\textcolor{keyword}{typename} AType, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{31 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} igl::for\_each(}
\DoxyCodeLine{32   \textcolor{keyword}{const} Eigen::SparseMatrix<AType> \& A,}
\DoxyCodeLine{33   \textcolor{keyword}{const} Func \& func)}
\DoxyCodeLine{34 \{}
\DoxyCodeLine{35   \textcolor{comment}{// Can **not** use parallel for because this must be \_in order\_}}
\DoxyCodeLine{36   \textcolor{comment}{// Iterate over outside}}
\DoxyCodeLine{37   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k=0; k<A.outerSize(); ++k)}
\DoxyCodeLine{38   \{}
\DoxyCodeLine{39     \textcolor{comment}{// Iterate over inside}}
\DoxyCodeLine{40     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} Eigen::SparseMatrix<AType>::InnerIterator it (A,k); it; ++it)}
\DoxyCodeLine{41     \{}
\DoxyCodeLine{42       func(it.row(),it.col(),it.value());}
\DoxyCodeLine{43     \}}
\DoxyCodeLine{44   \}}
\DoxyCodeLine{45 \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{48 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} igl::for\_each(}
\DoxyCodeLine{49   \textcolor{keyword}{const} Eigen::DenseBase<DerivedA> \& A,}
\DoxyCodeLine{50   \textcolor{keyword}{const} Func \& func)}
\DoxyCodeLine{51 \{}
\DoxyCodeLine{52   \textcolor{comment}{// Can **not** use parallel for because this must be \_in order\_}}
\DoxyCodeLine{53   \textcolor{keywordflow}{if}(A.IsRowMajor)}
\DoxyCodeLine{54   \{}
\DoxyCodeLine{55     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} DerivedA::Index i = 0;i<A.rows();i++)}
\DoxyCodeLine{56     \{}
\DoxyCodeLine{57       \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} DerivedA::Index j = 0;j<A.cols();j++)}
\DoxyCodeLine{58       \{}
\DoxyCodeLine{59         func(i,j,A(i,j));}
\DoxyCodeLine{60       \}}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62   \}\textcolor{keywordflow}{else}}
\DoxyCodeLine{63   \{}
\DoxyCodeLine{64     \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} DerivedA::Index j = 0;j<A.cols();j++)}
\DoxyCodeLine{65     \{}
\DoxyCodeLine{66       \textcolor{keywordflow}{for}(\textcolor{keyword}{typename} DerivedA::Index i = 0;i<A.rows();i++)}
\DoxyCodeLine{67       \{}
\DoxyCodeLine{68         func(i,j,A(i,j));}
\DoxyCodeLine{69       \}}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71   \}}
\DoxyCodeLine{72   }
\DoxyCodeLine{73 \}}
\DoxyCodeLine{74 }
\DoxyCodeLine{75 \textcolor{comment}{//\#ifndef IGL\_STATIC\_LIBRARY}}
\DoxyCodeLine{76 \textcolor{comment}{//\#  include "{}for\_each.cpp"{}}}
\DoxyCodeLine{77 \textcolor{comment}{//\#endif}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
