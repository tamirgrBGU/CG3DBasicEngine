\hypertarget{tinyply_8h_source}{}\doxysection{tinyply.\+h}
\label{tinyply_8h_source}\index{igl/tinyply.h@{igl/tinyply.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * tinyply 2.3.2 (https://github.com/ddiakopoulos/tinyply)}}
\DoxyCodeLine{3 \textcolor{comment}{ *}}
\DoxyCodeLine{4 \textcolor{comment}{ * A single-\/header, zero-\/dependency (except the C++ STL) public domain implementation}}
\DoxyCodeLine{5 \textcolor{comment}{ * of the PLY mesh file format. Requires C++11; errors are handled through exceptions.}}
\DoxyCodeLine{6 \textcolor{comment}{ *}}
\DoxyCodeLine{7 \textcolor{comment}{ * This software is in the public domain. Where that dedication is not}}
\DoxyCodeLine{8 \textcolor{comment}{ * recognized, you are granted a perpetual, irrevocable license to copy,}}
\DoxyCodeLine{9 \textcolor{comment}{ * distribute, and modify this file as you see fit.}}
\DoxyCodeLine{10 \textcolor{comment}{ *}}
\DoxyCodeLine{11 \textcolor{comment}{ * Authored by Dimitri Diakopoulos (http://www.dimitridiakopoulos.com)}}
\DoxyCodeLine{12 \textcolor{comment}{ *}}
\DoxyCodeLine{13 \textcolor{comment}{ * tinyply.h may be included in many files, however in a single compiled file,}}
\DoxyCodeLine{14 \textcolor{comment}{ * the implementation must be created with the following defined prior to header inclusion}}
\DoxyCodeLine{15 \textcolor{comment}{ * \#define TINYPLY\_IMPLEMENTATION}}
\DoxyCodeLine{16 \textcolor{comment}{ *}}
\DoxyCodeLine{17 \textcolor{comment}{ */}}
\DoxyCodeLine{18 }
\DoxyCodeLine{20 \textcolor{comment}{//   tinyply header   //}}
\DoxyCodeLine{22 \textcolor{comment}{}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#ifndef tinyply\_h}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#define tinyply\_h}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <igl/igl\_inline.h>}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{keyword}{namespace }igl}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40 \textcolor{keyword}{namespace }tinyply}
\DoxyCodeLine{41 \{}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{keyword}{enum class} Type : uint8\_t}
\DoxyCodeLine{44     \{}
\DoxyCodeLine{45         INVALID,}
\DoxyCodeLine{46         INT8,}
\DoxyCodeLine{47         UINT8,}
\DoxyCodeLine{48         INT16,}
\DoxyCodeLine{49         UINT16,}
\DoxyCodeLine{50         INT32,}
\DoxyCodeLine{51         UINT32,}
\DoxyCodeLine{52         FLOAT32,}
\DoxyCodeLine{53         FLOAT64}
\DoxyCodeLine{54     \};}
\DoxyCodeLine{55 }
\DoxyCodeLine{56     \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_property_info}{PropertyInfo}}}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58         \mbox{\hyperlink{structigl_1_1tinyply_1_1_property_info}{PropertyInfo}}() \{\};}
\DoxyCodeLine{59         \mbox{\hyperlink{structigl_1_1tinyply_1_1_property_info}{PropertyInfo}}(\textcolor{keywordtype}{int} stride, std::string str)}
\DoxyCodeLine{60             : stride(stride), str(str) \{\}}
\DoxyCodeLine{61         \textcolor{keywordtype}{int} stride \{0\};}
\DoxyCodeLine{62         std::string str;}
\DoxyCodeLine{63     \};}
\DoxyCodeLine{64 }
\DoxyCodeLine{65     \textcolor{keyword}{static} std::map<Type, PropertyInfo> PropertyTable}
\DoxyCodeLine{66     \{}
\DoxyCodeLine{67         \{ Type::INT8,    \mbox{\hyperlink{structigl_1_1tinyply_1_1_property_info}{PropertyInfo}}(1, std::string(\textcolor{stringliteral}{"{}char"{}})) \},}
\DoxyCodeLine{68         \{ Type::UINT8,   PropertyInfo(1, std::string(\textcolor{stringliteral}{"{}uchar"{}})) \},}
\DoxyCodeLine{69         \{ Type::INT16,   PropertyInfo(2, std::string(\textcolor{stringliteral}{"{}short"{}})) \},}
\DoxyCodeLine{70         \{ Type::UINT16,  PropertyInfo(2, std::string(\textcolor{stringliteral}{"{}ushort"{}})) \},}
\DoxyCodeLine{71         \{ Type::INT32,   PropertyInfo(4, std::string(\textcolor{stringliteral}{"{}int"{}})) \},}
\DoxyCodeLine{72         \{ Type::UINT32,  PropertyInfo(4, std::string(\textcolor{stringliteral}{"{}uint"{}})) \},}
\DoxyCodeLine{73         \{ Type::FLOAT32, PropertyInfo(4, std::string(\textcolor{stringliteral}{"{}float"{}})) \},}
\DoxyCodeLine{74         \{ Type::FLOAT64, PropertyInfo(8, std::string(\textcolor{stringliteral}{"{}double"{}})) \},}
\DoxyCodeLine{75         \{ Type::INVALID, PropertyInfo(0, std::string(\textcolor{stringliteral}{"{}INVALID"{}}))\}}
\DoxyCodeLine{76     \};}
\DoxyCodeLine{77 }
\DoxyCodeLine{78     \textcolor{keyword}{class }\mbox{\hyperlink{classigl_1_1tinyply_1_1_buffer}{Buffer}}}
\DoxyCodeLine{79     \{}
\DoxyCodeLine{80         uint8\_t * alias\{ \textcolor{keyword}{nullptr} \};}
\DoxyCodeLine{81         \textcolor{keyword}{struct }delete\_array \{ \textcolor{keywordtype}{void} operator()(uint8\_t * p) \{ \textcolor{keyword}{delete}[] p; \} \};}
\DoxyCodeLine{82         std::unique\_ptr<uint8\_t, \textcolor{keyword}{decltype}(Buffer::delete\_array())> data;}
\DoxyCodeLine{83         \textcolor{keywordtype}{size\_t} size \{0\};}
\DoxyCodeLine{84     \textcolor{keyword}{public}:}
\DoxyCodeLine{85         \mbox{\hyperlink{classigl_1_1tinyply_1_1_buffer}{Buffer}}() \{\};}
\DoxyCodeLine{86         \mbox{\hyperlink{classigl_1_1tinyply_1_1_buffer}{Buffer}}(\textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} size) : data(\textcolor{keyword}{new} uint8\_t[size], delete\_array()), size(size) \{ alias = data.get(); \} \textcolor{comment}{// allocating}}
\DoxyCodeLine{87         \mbox{\hyperlink{classigl_1_1tinyply_1_1_buffer}{Buffer}}(uint8\_t * ptr): alias(ptr) \{ \} \textcolor{comment}{// non-\/allocating, todo: set size?}}
\DoxyCodeLine{88         uint8\_t * get() \{ \textcolor{keywordflow}{return} alias; \}}
\DoxyCodeLine{89         \textcolor{keywordtype}{size\_t} size\_bytes()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} size; \}}
\DoxyCodeLine{90     \};}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_data}{PlyData}}}
\DoxyCodeLine{93     \{}
\DoxyCodeLine{94         Type t;}
\DoxyCodeLine{95         \mbox{\hyperlink{classigl_1_1tinyply_1_1_buffer}{Buffer}} buffer;}
\DoxyCodeLine{96         \textcolor{keywordtype}{size\_t} count \{0\};}
\DoxyCodeLine{97         \textcolor{keywordtype}{bool} isList \{\textcolor{keyword}{false}\};}
\DoxyCodeLine{98     \};}
\DoxyCodeLine{99 }
\DoxyCodeLine{100     \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_property}{PlyProperty}}}
\DoxyCodeLine{101     \{}
\DoxyCodeLine{102         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_property}{PlyProperty}}(std::istream \& is);}
\DoxyCodeLine{103         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_property}{PlyProperty}}(Type type, std::string \& \_name) : name(\_name), propertyType(type) \{\}}
\DoxyCodeLine{104         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_property}{PlyProperty}}(Type list\_type, Type prop\_type, std::string \& \_name, \textcolor{keywordtype}{size\_t} list\_count)}
\DoxyCodeLine{105             : name(\_name), propertyType(prop\_type), isList(\textcolor{keyword}{true}), listType(list\_type), listCount(list\_count) \{\}}
\DoxyCodeLine{106         std::string name;}
\DoxyCodeLine{107         Type propertyType\{ Type::INVALID \};}
\DoxyCodeLine{108         \textcolor{keywordtype}{bool} isList\{ \textcolor{keyword}{false} \};}
\DoxyCodeLine{109         Type listType\{ Type::INVALID \};}
\DoxyCodeLine{110         \textcolor{keywordtype}{size\_t} listCount \{0\};}
\DoxyCodeLine{111     \};}
\DoxyCodeLine{112 }
\DoxyCodeLine{113     \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_element}{PlyElement}}}
\DoxyCodeLine{114     \{}
\DoxyCodeLine{115         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_element}{PlyElement}}(std::istream \& istream);}
\DoxyCodeLine{116         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_element}{PlyElement}}(\textcolor{keyword}{const} std::string \& \_name, \textcolor{keywordtype}{size\_t} count) : name(\_name), size(count) \{\}}
\DoxyCodeLine{117         std::string name;}
\DoxyCodeLine{118         \textcolor{keywordtype}{size\_t} size \{0\};}
\DoxyCodeLine{119         std::vector<PlyProperty> properties;}
\DoxyCodeLine{120     \};}
\DoxyCodeLine{121 }
\DoxyCodeLine{122     \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_file}{PlyFile}}}
\DoxyCodeLine{123     \{}
\DoxyCodeLine{124         \textcolor{keyword}{struct }\mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_file_1_1_ply_file_impl}{PlyFileImpl}};}
\DoxyCodeLine{125         std::unique\_ptr<PlyFileImpl> impl;}
\DoxyCodeLine{126 }
\DoxyCodeLine{127         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_file}{PlyFile}}();}
\DoxyCodeLine{128         \mbox{\hyperlink{structigl_1_1tinyply_1_1_ply_file}{\string~PlyFile}}();}
\DoxyCodeLine{129 }
\DoxyCodeLine{130         \textcolor{comment}{/*}}
\DoxyCodeLine{131 \textcolor{comment}{         * The ply format requires an ascii header. This can be used to determine at}}
\DoxyCodeLine{132 \textcolor{comment}{         * runtime which properties or elements exist in the file. Limited validation of the}}
\DoxyCodeLine{133 \textcolor{comment}{         * header is performed; it is assumed the header correctly reflects the contents of the}}
\DoxyCodeLine{134 \textcolor{comment}{         * payload. This function may throw. Returns true on success, false on failure.}}
\DoxyCodeLine{135 \textcolor{comment}{         */}}
\DoxyCodeLine{136         \textcolor{keywordtype}{bool} parse\_header(std::istream \& is);}
\DoxyCodeLine{137 }
\DoxyCodeLine{138         \textcolor{comment}{/*}}
\DoxyCodeLine{139 \textcolor{comment}{         * Execute a read operation. Data must be requested via `request\_properties\_from\_element(...)`}}
\DoxyCodeLine{140 \textcolor{comment}{         * prior to calling this function.}}
\DoxyCodeLine{141 \textcolor{comment}{         */}}
\DoxyCodeLine{142         \textcolor{keywordtype}{void} read(std::istream \& is);}
\DoxyCodeLine{143 }
\DoxyCodeLine{144         \textcolor{comment}{/*}}
\DoxyCodeLine{145 \textcolor{comment}{         * `write` performs no validation and assumes that the data passed into}}
\DoxyCodeLine{146 \textcolor{comment}{         * `add\_properties\_to\_element` is well-\/formed.}}
\DoxyCodeLine{147 \textcolor{comment}{         */}}
\DoxyCodeLine{148         \textcolor{keywordtype}{void} write(std::ostream \& os, \textcolor{keywordtype}{bool} isBinary);}
\DoxyCodeLine{149 }
\DoxyCodeLine{150         \textcolor{comment}{/*}}
\DoxyCodeLine{151 \textcolor{comment}{         * These functions are valid after a call to `parse\_header(...)`. In the case of}}
\DoxyCodeLine{152 \textcolor{comment}{         * writing, get\_comments() reference may also be used to add new comments to the ply header.}}
\DoxyCodeLine{153 \textcolor{comment}{         */}}
\DoxyCodeLine{154         std::vector<PlyElement> get\_elements() \textcolor{keyword}{const};}
\DoxyCodeLine{155         std::vector<std::string> get\_info() \textcolor{keyword}{const};}
\DoxyCodeLine{156         std::vector<std::string> \& get\_comments();}
\DoxyCodeLine{157         \textcolor{keywordtype}{bool} is\_binary\_file() \textcolor{keyword}{const};}
\DoxyCodeLine{158 }
\DoxyCodeLine{159         \textcolor{comment}{/*}}
\DoxyCodeLine{160 \textcolor{comment}{         * In the general case where |list\_size\_hint| is zero, `read` performs a two-\/pass}}
\DoxyCodeLine{161 \textcolor{comment}{         * parse to support variable length lists. The most general use of the}}
\DoxyCodeLine{162 \textcolor{comment}{         * ply format is storing triangle meshes. When this fact is known a-\/priori, we can pass}}
\DoxyCodeLine{163 \textcolor{comment}{         * an expected list length that will apply to this element. Doing so results in an up-\/front}}
\DoxyCodeLine{164 \textcolor{comment}{         * memory allocation and a single-\/pass import, a 2x performance optimization.}}
\DoxyCodeLine{165 \textcolor{comment}{         */}}
\DoxyCodeLine{166         std::shared\_ptr<PlyData> request\_properties\_from\_element(\textcolor{keyword}{const} std::string \& elementKey,}
\DoxyCodeLine{167             \textcolor{keyword}{const} std::vector<std::string> propertyKeys, \textcolor{keyword}{const} uint32\_t list\_size\_hint = 0);}
\DoxyCodeLine{168 }
\DoxyCodeLine{169         \textcolor{keywordtype}{void} add\_properties\_to\_element(\textcolor{keyword}{const} std::string \& elementKey,}
\DoxyCodeLine{170             \textcolor{keyword}{const} std::vector<std::string> propertyKeys,}
\DoxyCodeLine{171             \textcolor{keyword}{const} Type type,}
\DoxyCodeLine{172             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} count,}
\DoxyCodeLine{173             uint8\_t * data,}
\DoxyCodeLine{174             \textcolor{keyword}{const} Type listType,}
\DoxyCodeLine{175             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} listCount);}
\DoxyCodeLine{176     \};}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \} \textcolor{comment}{// end namespace tinyply}}
\DoxyCodeLine{179 \} \textcolor{comment}{// end namespace igl}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#ifndef IGL\_STATIC\_LIBRARY}}
\DoxyCodeLine{182 \textcolor{comment}{// implementation moved to tinyply.cpp}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#  include "{}tinyply.cpp"{}}}
\DoxyCodeLine{184 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// end tinyply\_h}}

\end{DoxyCode}
